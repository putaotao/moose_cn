# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-01-05 19:50+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: BestPractices.pod:9
msgid "NAME"
msgstr ""

#. type: textblock
#: BestPractices.pod:11
msgid "Moose::Manual::BestPractices - Get the most out of Moose"
msgstr ""

#. type: =head1
#: BestPractices.pod:13
msgid "VERSION"
msgstr ""

#. type: textblock
#: BestPractices.pod:15
msgid "version 2.0401"
msgstr ""

#. type: =head1
#: BestPractices.pod:17
msgid "RECOMMENDATIONS"
msgstr ""

#. type: textblock
#: BestPractices.pod:19
msgid ""
"Moose has a lot of features, and there's definitely more than one way to do "
"it. However, we think that picking a subset of these features and using them "
"consistently makes everyone's life easier."
msgstr ""

#. type: textblock
#: BestPractices.pod:23
msgid ""
"Of course, as with any list of \"best practices\", these are really just "
"opinions. Feel free to ignore us."
msgstr ""

#. type: =head2
#: BestPractices.pod:26
msgid "C<namespace::autoclean> and immutabilize"
msgstr ""

#. type: textblock
#: BestPractices.pod:28
msgid ""
"We recommend that you remove the Moose sugar and end your Moose class "
"definitions by making your class immutable."
msgstr ""

#. type: verbatim
#: BestPractices.pod:31
#, no-wrap
msgid ""
"  package Person;\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:33
#, no-wrap
msgid ""
"  use Moose;\n"
"  use namespace::autoclean;\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:36
#, no-wrap
msgid ""
"  # extends, roles, attributes, etc.\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:38
#, no-wrap
msgid ""
"  # methods\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:40
#, no-wrap
msgid ""
"  __PACKAGE__->meta->make_immutable;\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:42
#, no-wrap
msgid ""
"  1;\n"
"\n"
msgstr ""

#. type: textblock
#: BestPractices.pod:44
msgid ""
"The C<use namespace::autoclean> bit is simply good code hygiene, as it "
"removes imported symbols from your class's namespace at the end of your "
"package's compile cycle, including Moose keywords.  Once the class has been "
"built, these keywords are not needed. (This is preferred to placing C<no "
"Moose> at the end of your package)."
msgstr ""

#. type: textblock
#: BestPractices.pod:50
msgid ""
"The C<make_immutable> call allows Moose to speed up a lot of things, most "
"notably object construction. The trade-off is that you can no longer change "
"the class definition."
msgstr ""

#. type: =head2
#: BestPractices.pod:54
msgid "Never override C<new>"
msgstr ""

#. type: textblock
#: BestPractices.pod:56
msgid ""
"Overriding C<new> is a very bad practice. Instead, you should use a C<BUILD> "
"or C<BUILDARGS> methods to do the same thing. When you override C<new>, "
"Moose can no longer inline a constructor when your class is immutabilized."
msgstr ""

#. type: textblock
#: BestPractices.pod:61
msgid ""
"There are two good reasons to override C<new>. One, you are writing a MooseX "
"extension that provides its own L<Moose::Object> subclass I<and> a subclass "
"of L<Moose::Meta::Method::Constructor> to inline the constructor. Two, you "
"are subclassing a non-Moose parent."
msgstr ""

#. type: textblock
#: BestPractices.pod:66
msgid "If you know how to do that, you know when to ignore this best practice ;)"
msgstr ""

#. type: =head2
#: BestPractices.pod:69
msgid "Always call the original/parent C<BUILDARGS>"
msgstr ""

#. type: textblock
#: BestPractices.pod:71
msgid ""
"If you C<override> the C<BUILDARGS> method in your class, make sure to play "
"nice and call C<super()> to handle cases you're not checking for explicitly."
msgstr ""

#. type: textblock
#: BestPractices.pod:74
msgid ""
"The default C<BUILDARGS> method in L<Moose::Object> handles both a list and "
"hashref of named parameters correctly, and also checks for a I<non-hashref> "
"single argument."
msgstr ""

#. type: =head2
#: BestPractices.pod:78
msgid "Provide defaults whenever possible, otherwise use C<required>"
msgstr ""

#. type: textblock
#: BestPractices.pod:80
msgid ""
"When your class provides defaults, this makes constructing new objects "
"simpler. If you cannot provide a default, consider making the attribute "
"C<required>."
msgstr ""

#. type: textblock
#: BestPractices.pod:84
msgid ""
"If you don't do either, an attribute can simply be left unset, increasing "
"the complexity of your object, because it has more possible states that you "
"or the user of your class must account for."
msgstr ""

#. type: =head2
#: BestPractices.pod:88
msgid "Use C<builder> instead of C<default> most of the time"
msgstr ""

#. type: textblock
#: BestPractices.pod:90
msgid ""
"Builders can be inherited, they have explicit names, and they're just plain "
"cleaner."
msgstr ""

#. type: textblock
#: BestPractices.pod:93
msgid ""
"However, I<do> use a default when the default is a non-reference, I<or> when "
"the default is simply an empty reference of some sort."
msgstr ""

#. type: textblock
#: BestPractices.pod:96
msgid "Also, keep your builder methods private."
msgstr ""

#. type: =head2
#: BestPractices.pod:98
msgid "Be C<lazy>"
msgstr ""

#. type: textblock
#: BestPractices.pod:100
msgid ""
"Lazy is good, and often solves initialization ordering problems. It's also "
"good for deferring work that may never have to be done. Make your attributes "
"C<lazy> unless they're C<required> or have trivial defaults."
msgstr ""

#. type: =head2
#: BestPractices.pod:104
msgid "Consider keeping clearers and predicates private"
msgstr ""

#. type: textblock
#: BestPractices.pod:106
msgid ""
"Does everyone I<really> need to be able to clear an attribute? Probably "
"not. Don't expose this functionality outside your class by default."
msgstr ""

#. type: textblock
#: BestPractices.pod:110
msgid ""
"Predicates are less problematic, but there's no reason to make your public "
"API bigger than it has to be."
msgstr ""

#. type: =head2
#: BestPractices.pod:113
msgid "Default to read-only, and consider keeping writers private"
msgstr ""

#. type: textblock
#: BestPractices.pod:115
msgid ""
"Making attributes mutable just means more complexity to account for in your "
"program. The alternative to mutable state is to encourage users of your "
"class to simply make new objects as needed."
msgstr ""

#. type: textblock
#: BestPractices.pod:119
msgid ""
"If you I<must> make an attribute read-write, consider making the writer a "
"separate private method. Narrower APIs are easy to maintain, and mutable "
"state is trouble."
msgstr ""

#. type: textblock
#: BestPractices.pod:123
msgid "In order to declare such attributes, provide a private C<writer> parameter:"
msgstr ""

#. type: verbatim
#: BestPractices.pod:126
#, no-wrap
msgid ""
"    has pizza => (\n"
"        is     => 'ro',\n"
"        isa    => 'Pizza',\n"
"        writer => '_pizza',\n"
"    );\n"
"\n"
msgstr ""

#. type: =head2
#: BestPractices.pod:132
msgid "Think twice before changing an attribute's type in a subclass"
msgstr ""

#. type: textblock
#: BestPractices.pod:134
msgid ""
"Down this path lies great confusion. If the attribute is an object itself, "
"at least make sure that it has the same interface as the type of object in "
"the parent class."
msgstr ""

#. type: =head2
#: BestPractices.pod:138
msgid "Don't use the C<initializer> feature"
msgstr ""

#. type: textblock
#: BestPractices.pod:140
msgid "Don't know what we're talking about? That's fine."
msgstr ""

#. type: =head2
#: BestPractices.pod:142
msgid "Use L<Moose::Meta::Attribute::Native> traits instead of C<auto_deref>"
msgstr ""

#. type: textblock
#: BestPractices.pod:144
msgid ""
"The C<auto_deref> feature is a bit troublesome. Directly exposing a complex "
"attribute is ugly. Instead, consider using L<Moose::Meta::Attribute::Native> "
"traits to define an API that only exposes the necessary pieces of "
"functionality."
msgstr ""

#. type: =head2
#: BestPractices.pod:149
msgid "Always call C<inner> in the most specific subclass"
msgstr ""

#. type: textblock
#: BestPractices.pod:151
msgid ""
"When using C<augment> and C<inner>, we recommend that you call C<inner> in "
"the most specific subclass of your hierarchy. This makes it possible to "
"subclass further and extend the hierarchy without changing the parents."
msgstr ""

#. type: =head2
#: BestPractices.pod:156
msgid "Namespace your types"
msgstr ""

#. type: textblock
#: BestPractices.pod:158
msgid ""
"Use some sort of namespacing convention for type names. We recommend "
"something like \"MyApp::Type::Foo\". We also recommend considering "
"L<MooseX::Types>."
msgstr ""

#. type: =head2
#: BestPractices.pod:161
msgid "Do not coerce Moose built-ins directly"
msgstr ""

#. type: textblock
#: BestPractices.pod:163
msgid ""
"If you define a coercion for a Moose built-in like C<ArrayRef>, this will "
"affect every application in the Perl interpreter that uses this type."
msgstr ""

#. type: verbatim
#: BestPractices.pod:167
#, no-wrap
msgid ""
"    # very naughty!\n"
"    coerce 'ArrayRef'\n"
"        => from Str\n"
"        => via { [ split /,/ ] };\n"
"\n"
msgstr ""

#. type: textblock
#: BestPractices.pod:172
msgid "Instead, create a subtype and coerce that:"
msgstr ""

#. type: verbatim
#: BestPractices.pod:174
#, no-wrap
msgid ""
"    subtype 'My::ArrayRef' => as 'ArrayRef';\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:176
#, no-wrap
msgid ""
"    coerce 'My::ArrayRef'\n"
"        => from 'Str'\n"
"        => via { [ split /,/ ] };\n"
"\n"
msgstr ""

#. type: =head2
#: BestPractices.pod:180
msgid "Do not coerce class names directly"
msgstr ""

#. type: textblock
#: BestPractices.pod:182
msgid ""
"Just as with Moose built-in types, a class type is global for the entire "
"interpreter. If you add a coercion for that class name, it can have magical "
"side effects elsewhere:"
msgstr ""

#. type: verbatim
#: BestPractices.pod:186
#, no-wrap
msgid ""
"    # also very naughty!\n"
"    coerce 'HTTP::Headers'\n"
"        => from 'HashRef'\n"
"        => via { HTTP::Headers->new( %{$_} ) };\n"
"\n"
msgstr ""

#. type: textblock
#: BestPractices.pod:191
msgid "Instead, we can create an \"empty\" subtype for the coercion:"
msgstr ""

#. type: verbatim
#: BestPractices.pod:193
#, no-wrap
msgid ""
"    subtype 'My::HTTP::Headers' => as class_type('HTTP::Headers');\n"
"\n"
msgstr ""

#. type: verbatim
#: BestPractices.pod:195
#, no-wrap
msgid ""
"    coerce 'My::HTTP::Headers'\n"
"        => from 'HashRef'\n"
"        => via { HTTP::Headers->new( %{$_} ) };\n"
"\n"
msgstr ""

#. type: =head2
#: BestPractices.pod:199
msgid "Use coercion instead of unions"
msgstr ""

#. type: textblock
#: BestPractices.pod:201
msgid ""
"Consider using a type coercion instead of a type union. This was covered in "
"L<Moose::Manual::Types>."
msgstr ""

#. type: =head2
#: BestPractices.pod:204
msgid "Define all your types in one module"
msgstr ""

#. type: textblock
#: BestPractices.pod:206
msgid ""
"Define all your types and coercions in one module. This was also covered in "
"L<Moose::Manual::Types>."
msgstr ""

#. type: =head1
#: BestPractices.pod:209
msgid "BENEFITS OF BEST PRACTICES"
msgstr ""

#. type: textblock
#: BestPractices.pod:211
msgid "Following these practices has a number of benefits."
msgstr ""

#. type: textblock
#: BestPractices.pod:213
msgid ""
"It helps ensure that your code will play nice with others, making it more "
"reusable and easier to extend."
msgstr ""

#. type: textblock
#: BestPractices.pod:216
msgid ""
"Following an accepted set of idioms will make maintenance easier, especially "
"when someone else has to maintain your code. It will also make it easier to "
"get support from other Moose users, since your code will be easier to digest "
"quickly."
msgstr ""

#. type: textblock
#: BestPractices.pod:221
msgid ""
"Some of these practices are designed to help Moose do the right thing, "
"especially when it comes to immutabilization. This means your code will be "
"faster when immutabilized."
msgstr ""

#. type: textblock
#: BestPractices.pod:225
msgid ""
"Many of these practices also help get the most out of meta programming. If "
"you used an overridden C<new> to do type coercion by hand, rather than "
"defining a real coercion, there is no introspectable metadata. This sort of "
"thing is particularly problematic for MooseX extensions which rely on "
"introspection to do the right thing."
msgstr ""

#. type: =head1
#: BestPractices.pod:231
msgid "AUTHOR"
msgstr ""

#. type: textblock
#: BestPractices.pod:233
msgid ""
"Moose is maintained by the Moose Cabal, along with the help of many "
"contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details."
msgstr ""

#. type: =head1
#: BestPractices.pod:235
msgid "COPYRIGHT AND LICENSE"
msgstr ""

#. type: textblock
#: BestPractices.pod:237
msgid "This software is copyright (c) 2011 by Infinity Interactive, Inc.."
msgstr ""

#. type: textblock
#: BestPractices.pod:239
msgid ""
"This is free software; you can redistribute it and/or modify it under the "
"same terms as the Perl 5 programming language system itself."
msgstr ""
